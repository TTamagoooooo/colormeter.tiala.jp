<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å†™çœŸè‰²ç›¸åˆ†æ| TIALA.</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Shippori+Mincho:wght@400;600&display=swap"
        rel="stylesheet">

    <!-- ãƒ•ã‚¡ãƒ“ã‚³ãƒ³ -->

    <!-- ICOãƒ•ã‚¡ã‚¤ãƒ« -->
    <link rel="icon" href="favicon.ico" />

    <!-- PNGï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç”¨ï¼‰ -->
    <link rel="icon" href="favicon.png" sizes="32x32" type="image/png">

    <style>
        :root {
            --bg: #f7f6f3;
            --fg: #111;
            --accent: #9aa7c1;
            --card-bg: rgba(255, 255, 255, 0.9);
            --border: rgba(0, 0, 0, 0.10);
            --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.07);
            --radius-card: 18px;
            --sans: "Inter", sans-serif;
            --serif: "Shippori Mincho", serif;
        }

        body {
            margin: 0;
            font-family: var(--serif);
            background: radial-gradient(circle at top, #fdfbf5 0, #f3f1eb 40%, #ece9e2 100%);
            color: var(--fg);
            -webkit-font-smoothing: antialiased;
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            padding: 3rem 1.4rem 4rem;
        }

        h1 {
            font-size: clamp(1.8rem, 3vw, 2.4rem);
            margin: 1rem 0 0.5rem;
        }

        .subtitle {
            max-width: 40rem;
            color: #6b665d;
            line-height: 1.8;
            font-size: 0.95rem;
        }

        .card {
            margin-top: 2.4rem;
            padding: 1.8rem;
            border-radius: var(--radius-card);
            background: var(--card-bg);
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border);
            backdrop-filter: blur(4px);
        }

        /* â–¼ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ */
        .mode-switch {
            display: flex;
            gap: 0.6rem;
            align-items: center;
            margin-bottom: 1.2rem;
            font-family: var(--sans);
            font-size: 0.8rem;
            color: #7b746a;
        }

        .mode-label {
            letter-spacing: 0.08em;
        }

        .mode-btn {
            border-radius: 999px;
            padding: 0.3rem 0.9rem;
            font-size: 0.78rem;
            letter-spacing: 0.08em;
            border: 1px solid rgba(0, 0, 0, 0.16);
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-family: var(--sans);
            opacity: 0.7;
            transition: background 0.2s ease, opacity 0.2s ease, transform 0.15s ease;
        }

        .mode-btn:hover {
            opacity: 1;
            transform: translateY(-1px);
        }

        .mode-btn.active {
            background: #ece7de;
            opacity: 1;
        }

        .mode-note {
            margin-top: 0.3rem;
            font-family: var(--sans);
            font-size: 0.75rem;
            color: #9a9187;
        }

        .upload-block {
            padding: 1.4rem 1rem 1.5rem;
            text-align: center;
            border: 2px dashed rgba(0, 0, 0, 0.15);
            border-radius: 14px;
            cursor: pointer;
            font-family: var(--sans);
            font-size: 0.9rem;
            color: #5c574f;
        }

        .upload-block input {
            display: none;
        }

        /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‹ãƒãƒ¼ã‚«ãƒ¼ï¼ˆå˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ï¼‰ */
        .preview-wrap {
            margin-top: 1.6rem;
            text-align: center;
            position: relative;
            display: inline-block;
        }

        .preview-image {
            max-width: 100%;
            border-radius: 14px;
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.07);
            display: block;
        }

        #markerLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .color-marker {
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .preview-note {
            margin-top: 0.5rem;
            font-family: var(--sans);
            font-size: 0.72rem;
            color: #9a948a;
        }

        /* â–¼ ã‚°ãƒ©ãƒ•åˆ‡ã‚Šæ›¿ãˆã‚¿ãƒ– */
        .graph-tabs {
            margin-top: 2.0rem;
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
            font-family: var(--sans);
        }

        .graph-tab {
            border-radius: 999px;
            padding: 0.35rem 0.9rem;
            font-size: 0.78rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            border: 1px solid rgba(0, 0, 0, 0.12);
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            opacity: 0.7;
            transition: background 0.25s ease, opacity 0.25s ease, transform 0.2s ease;
        }

        .graph-tab:hover {
            opacity: 0.95;
            transform: translateY(-1px);
        }

        .graph-tab.active {
            background: #ece7de;
            opacity: 1;
        }

        .graph-panels {
            margin-top: 1.4rem;
        }

        .graph-panel {
            display: none;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .graph-panel.active {
            display: block;
            opacity: 1;
        }

        .graph-title {
            font-family: var(--sans);
            color: #7a7468;
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            margin-bottom: 0.3rem;
        }

        .graph-canvas {
            width: 100%;
            height: 180px;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.05);
            background: transparent;
        }

        .graph-desc {
            margin-top: 0.55rem;
            font-family: var(--sans);
            font-size: 0.8rem;
            line-height: 1.7;
            color: #847d73;
        }

        /* â–¼ ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆå˜å†™çœŸæ™‚ãƒ¡ã‚¤ãƒ³ï¼‰ */
        .palette-wrap {
            margin-top: 2.4rem;
        }

        .color-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 1rem;
            margin-top: 1.4rem;
        }

        .color-box {
            height: 110px;
            border-radius: 14px;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08);
            position: relative;
            cursor: pointer;
        }

        .color-code {
            position: absolute;
            bottom: 6px;
            left: 10px;
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.75);
            font-family: var(--sans);
            font-size: 0.82rem;
            border-radius: 999px;
        }

        .poem-block {
            margin-top: 1.6rem;
            padding-top: 1rem;
            border-top: 1px dashed rgba(0, 0, 0, 0.1);
        }

        .poem-title {
            font-family: var(--sans);
            font-size: 0.75rem;
            color: #978f84;
            letter-spacing: 0.16em;
            margin-bottom: 0.2rem;
            text-transform: uppercase;
        }

        .poem-text {
            font-size: 0.95rem;
            line-height: 1.9;
            color: #5c564e;
        }

        /* â–¼ è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ï¼šåˆ†æã‚³ãƒ¡ãƒ³ãƒˆ */
        .analysis-comment {
            margin-top: 2.4rem;
            padding-top: 1.4rem;
            border-top: 1px dashed rgba(0, 0, 0, 0.12);
        }

        .analysis-title {
            font-family: var(--sans);
            font-size: 0.78rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: #8a8278;
            margin-bottom: 0.4rem;
        }

        .analysis-text {
            font-family: var(--sans);
            font-size: 0.88rem;
            line-height: 1.9;
            color: #4f4942;
            white-space: pre-line;
        }

        .analysis-note {
            margin-top: 0.3rem;
            font-family: var(--sans);
            font-size: 0.72rem;
            color: #a29a90;
        }

        /* â–¼ æˆ»ã‚‹ãƒœã‚¿ãƒ³ */
        .return-wrap {
            margin-top: 2.4rem;
            text-align: right;
        }

        .btn-return {
            padding: 0.48rem 1.2rem;
            border-radius: 999px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            background: rgba(255, 255, 255, 0.9);
            font-family: var(--sans);
            cursor: pointer;
            font-size: 0.82rem;
            letter-spacing: 0.1em;
        }

        .btn-return:hover {
            background: #f4f1eb;
        }

        .canvas-message {
            font-family: var(--sans);
            font-size: 0.78rem;
            fill: #756e64;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>è‰²ã®è¨˜æ†¶ãƒ‘ãƒ¬ãƒƒãƒˆ & ä½œé¢¨åˆ†æ</h1>
        <p class="subtitle">
            å˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ä¸€æšã®å†™çœŸã«å®¿ã‚‹è‰²ã¨å…‰ã®æ§‹é€ ã‚’ç´°ã‚„ã‹ã«å¯è¦–åŒ–ã—ã¾ã™ã€‚<br>
            <!--è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€æœ€å¤§100æšã®ä½œå“ã‹ã‚‰è‰²ç›¸ãƒ»æ˜åº¦ãƒ»å½©åº¦ã®å‚¾å‘ã‚’çµ±è¨ˆçš„ã«èª­ã¿è§£ãã€
            ã‚ãªãŸã®ä½œé¢¨ã®â€œè‰²ã®ç™–â€ã‚’åˆ†æã—ã¾ã™ã€‚-->
        </p>

        <div class="card">
            <!-- â–¼ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ -->
            <div class="mode-switch">
                <span class="mode-label">MODE</span>
                <button class="mode-btn active" data-mode="single">å˜å†™çœŸãƒ¢ãƒ¼ãƒ‰</button>
                <!-- <button class="mode-btn" data-mode="multi">è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰</button>-->
            </div>
            <div id="modeNote" class="mode-note">
                ä¸€æšã®å†™çœŸã‚’é¸æŠã—ã¦ã€è‰²ã¨å…‰ã®åˆ†å¸ƒã‚’è©³ã—ãè¦‹ã‚‹ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚
            </div>

            <!-- â–¼ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ -->
            <label class="upload-block">
                <input type="file" id="fileInput" accept="image/*" multiple>
                ğŸ“· ç”»åƒã‚’é¸æŠï¼ˆå˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ï¼š1æš <!--/ è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ï¼šæœ€å¤§100æšï¼‰-->
            </label>

            <!-- â–¼ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ã®ã¿ä½¿ç”¨ï¼‰ -->
            <div id="previewContainer" class="preview-wrap" style="display:none;">
                <img id="previewImg" class="preview-image">
                <div id="markerLayer"></div>
                <div class="preview-note">â€»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸç”»åƒã¯ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚</div>
            </div>

            <!-- â–¼ ã‚°ãƒ©ãƒ•åˆ‡ã‚Šæ›¿ãˆã‚¿ãƒ– -->
            <div class="graph-tabs">
                <button class="graph-tab active" data-graph="colorMap">Color Ã— Brightness</button>
                <button class="graph-tab" data-graph="hueCurve">Hue Curve</button>
                <button class="graph-tab" data-graph="toneCurve">Tone Curve</button>
                <button class="graph-tab" data-graph="colorBars">Color Bars</button>
            </div>

            <!-- â–¼ ã‚°ãƒ©ãƒ•é ˜åŸŸ -->
            <div class="graph-panels">
                <!-- 1. è‰²Ã—æ˜ã‚‹ã•ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ— -->
                <div class="graph-panel active" id="panel-colorMap">
                    <div class="graph-title">Color Ã— Brightness Map</div>
                    <canvas id="toneMapCanvas" class="graph-canvas"></canvas>
                    <div class="graph-desc">
                        æ¨ªè»¸ã¯é’ã€œæ©™ã¸ã¨æ»‘ã‚‰ã‹ã«ç§»ã‚ã†ã€Œè‰²ç›¸ã€ã€ç¸¦è»¸ã¯ä¸‹ã‹ã‚‰ä¸Šã¸ã€Œæš—éƒ¨â†’ãƒã‚¤ãƒ©ã‚¤ãƒˆã€ã®æ˜ã‚‹ã•ã‚’ç¤ºã—ã¾ã™ã€‚<br>
                        è‰²ãŒæ¿ƒãé‡ãªã£ã¦ã„ã‚‹å ´æ‰€ã»ã©ã€ãã®ã€Œè‰² Ã— æ˜ã‚‹ã•ã€ãŒå†™çœŸã®ä¸­ã«å¤šãå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
                        å·¦ä¸‹ã«å¯†åº¦ãŒã‚ã‚Œã°â€œå†·ãŸã„å½±â€ã€å³ä¸Šã«å¯†åº¦ãŒã‚ã‚Œã°â€œã‚ãŸãŸã‹ãªå…‰â€ãŒå¼·ã„ä½œå“ã§ã™ã€‚
                        <!-- ï¼ˆâ€»è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã¯å˜å†™çœŸã§ã®åˆ©ç”¨ã«é™å®šã•ã‚Œã¾ã™ï¼‰-->
                    </div>
                </div>

                <!-- 2. Hue Curve -->
                <div class="graph-panel" id="panel-hueCurve">
                    <div class="graph-title">Hue Distribution Curve</div>
                    <canvas id="hueCurveCanvas" class="graph-canvas"></canvas>
                    <div class="graph-desc">
                        å†™çœŸï¼ˆã¾ãŸã¯ä½œå“ç¾¤ï¼‰å…¨ä½“ã®ã€Œè‰²å‘³ã®åã‚Šã€ã‚’ä¸€ç­†æ›¸ãã®æ›²ç·šã§è¡¨ã—ãŸã‚°ãƒ©ãƒ•ã§ã™ã€‚<br>
                        èƒŒæ™¯ã®æ·¡ã„å¸¯ã¯ã€å·¦ã‹ã‚‰å³ã¸é’ãƒ»ç·‘ãƒ»é»„ãƒ»æ©™ãƒ»èµ¤ã®é †ã«ä¸¦ã¶è‰²ç›¸ã®æµã‚Œã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚<br>
                        ç·šãŒç››ã‚Šä¸ŠãŒã£ã¦ã„ã‚‹åŒºé–“ã»ã©ã€ãã®è‰²ç›¸ãŒå¤šãä½¿ã‚ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
                    </div>
                </div>

                <!-- 3. Tone Curve -->
                <div class="graph-panel" id="panel-toneCurve">
                    <div class="graph-title">Brightness Curve</div>
                    <canvas id="toneCurveCanvas" class="graph-canvas"></canvas>
                    <div class="graph-desc">
                        ç”»é¢å…¨ä½“ã®ã€Œæ˜ã‚‹ã•ã®åˆ†å¸ƒã€ã‚’ãƒˆãƒ¼ãƒ³ã‚«ãƒ¼ãƒ–é¢¨ã«æã„ãŸã‚‚ã®ã§ã™ã€‚<br>
                        èƒŒæ™¯ã®å¸¯ã¯ã€å·¦ã‹ã‚‰å³ã¸ã€Œæš—éƒ¨ â†’ ä¸­é–“èª¿ â†’ ãƒã‚¤ãƒ©ã‚¤ãƒˆã€ã¸ã®æµã‚Œã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚<br>
                        å·¦ãŒé«˜ã‘ã‚Œã°ãƒ­ãƒ¼ã‚­ãƒ¼ã€å³ãŒé«˜ã‘ã‚Œã°ãƒã‚¤ã‚­ãƒ¼ã€ä¸­å¤®ãŒé«˜ã‘ã‚Œã°ä¸­é–“èª¿ã®æ¯”ç‡ãŒé«˜ã„æ§‹æˆã§ã™ã€‚
                    </div>
                </div>

                <!-- 4. è‰²åˆ†å¸ƒãƒãƒ¼ -->
                <div class="graph-panel" id="panel-colorBars">
                    <div class="graph-title">Color Distribution Bars</div>
                    <canvas id="colorBarCanvas" class="graph-canvas"></canvas>
                    <div class="graph-desc">
                        è‰²ç›¸ã‚’ã„ãã¤ã‹ã®åŒºé–“ã«åˆ†ã‘ã€ãã‚Œãã‚Œã®è‰²ãŒã©ã‚Œã ã‘ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ã‚’ãƒãƒ¼ã§ç¤ºã—ãŸã‚‚ã®ã§ã™ã€‚<br>
                        <!--è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€é¸æŠã—ãŸå…¨ç”»åƒã®å¹³å‡å‚¾å‘ã¨ã—ã¦ã€ã©ã®è‰²åŸŸã‚’å¤šãä½¿ã†ä½œé¢¨ãªã®ã‹ã‚’ä¿¯ç°ã§ãã¾ã™ã€‚-->
                    </div>
                </div>
            </div>

            <!-- â–¼ ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆä¸»ã«å˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ï¼‰ -->
            <div id="paletteArea"></div>

            <!-- â–¼ è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ï¼šä½œé¢¨åˆ†æã‚³ãƒ¡ãƒ³ãƒˆ -->
            <div id="multiCommentBlock" class="analysis-comment" style="display:none;">
                <div class="analysis-title">ä½œå“ç¾¤ã®è‰²ã¨å…‰ã®å‚¾å‘</div>
                <div id="analysisText" class="analysis-text"></div>
                <div class="analysis-note">
                    <!--â€»è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸå…¨ç”»åƒã®å¹³å‡çš„ãªè‰²ç›¸ãƒ»æ˜åº¦ãƒ»å½©åº¦ã®åˆ†å¸ƒã‹ã‚‰ã€
                    ä½œé¢¨ã®ç‰¹å¾´ã‚’çµ±è¨ˆçš„ã«è¦ç´„ã—ãŸã‚³ãƒ¡ãƒ³ãƒˆã§ã™ã€‚-->
                </div>
            </div>
        </div>

        <div class="return-wrap">
            <button class="btn-return" onclick="window.location.href='https://tiala.jp/tools'">â† TIALA Toolsã¸æˆ»ã‚‹</button>
        </div>
    </div>

    <!-- å†…éƒ¨å‡¦ç†ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆéè¡¨ç¤ºï¼‰-->
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // ========= DOMå‚ç…§ =========
        const fileInput = document.getElementById("fileInput");
        const previewImg = document.getElementById("previewImg");
        const previewContainer = document.getElementById("previewContainer");
        const markerLayer = document.getElementById("markerLayer");
        const paletteArea = document.getElementById("paletteArea");
        const modeNote = document.getElementById("modeNote");
        const multiCommentBlock = document.getElementById("multiCommentBlock");
        const analysisText = document.getElementById("analysisText");

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const tabs = document.querySelectorAll(".graph-tab");
        const panels = document.querySelectorAll(".graph-panel");
        const modeButtons = document.querySelectorAll(".mode-btn");

        const toneMapCanvas = document.getElementById("toneMapCanvas");
        const toneMapCtx = toneMapCanvas.getContext("2d");

        const hueCurveCanvas = document.getElementById("hueCurveCanvas");
        const hueCurveCtx = hueCurveCanvas.getContext("2d");

        const toneCurveCanvas = document.getElementById("toneCurveCanvas");
        const toneCurveCtx = toneCurveCanvas.getContext("2d");

        const colorBarCanvas = document.getElementById("colorBarCanvas");
        const colorBarCtx = colorBarCanvas.getContext("2d");

        let mode = "single";        // "single" or "multi"
        let currentImage = null;    // å˜å†™çœŸãƒ¢ãƒ¼ãƒ‰ç”¨

        // ========= ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ =========
        modeButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                modeButtons.forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                mode = btn.dataset.mode;

                if (mode === "single") {
                    modeNote.textContent = "ä¸€æšã®å†™çœŸã‚’é¸æŠã—ã¦ã€è‰²ã¨å…‰ã®åˆ†å¸ƒã‚’è©³ã—ãè¦‹ã‚‹ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚";
                    previewContainer.style.display = currentImage ? "inline-block" : "none";
                    multiCommentBlock.style.display = "none";
                    paletteArea.innerHTML = "";
                } else {
                    modeNote.textContent = "æœ€å¤§100æšã¾ã§ã®ä½œå“ç¾¤ã‹ã‚‰ã€è‰²ç›¸ãƒ»æ˜åº¦ãƒ»å½©åº¦ã®å‚¾å‘ã‚’ã¾ã¨ã‚ã¦åˆ†æã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚";
                    previewContainer.style.display = "none";
                    markerLayer.innerHTML = "";
                    paletteArea.innerHTML = "";
                    multiCommentBlock.style.display = "none";
                }

                // ã‚°ãƒ©ãƒ•ã‚’ã‚¯ãƒªã‚¢
                clearCanvas(toneMapCtx, toneMapCanvas);
                clearCanvas(hueCurveCtx, hueCurveCanvas);
                clearCanvas(toneCurveCtx, toneCurveCanvas);
                clearCanvas(colorBarCtx, colorBarCanvas);
            });
        });

        // ========= ã‚°ãƒ©ãƒ•ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ =========
        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                tab.classList.add("active");

                const target = tab.dataset.graph;

                panels.forEach(panel => {
                    panel.classList.remove("active");
                });

                const activePanel = document.getElementById("panel-" + target);
                activePanel.classList.add("active");

                // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å†æç”»
                setTimeout(() => {
                    if (mode === "single" && currentImage) {
                        if (target === "colorMap") drawColorBrightnessMap(currentImage);
                        if (target === "hueCurve") drawHueCurveFromImage(currentImage);
                        if (target === "toneCurve") drawToneCurveFromImage(currentImage);
                        if (target === "colorBars") drawColorBarsSingle(currentImage);
                    }
                }, 50);
            });
        });

        // ========= ç”»åƒå…¥åŠ›ãƒãƒ³ãƒ‰ãƒ© =========
        fileInput.addEventListener("change", async (e) => {
            const files = Array.from(e.target.files || []);
            if (!files.length) return;

            if (mode === "single") {
                const file = files[0];
                await handleSingleImage(file);
            } else {
                await handleMultiImages(files.slice(0, 100));
            }
        });

        // ========= å˜å†™çœŸãƒ¢ãƒ¼ãƒ‰å‡¦ç† =========
        async function handleSingleImage(file) {
            const imgURL = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                currentImage = img;
                previewImg.src = imgURL;
                previewContainer.style.display = "inline-block";

                extractPalette(img);
                drawColorBrightnessMap(img);
                drawHueCurveFromImage(img);
                drawToneCurveFromImage(img);
                drawColorBarsSingle(img);
                multiCommentBlock.style.display = "none";
            };
            img.src = imgURL;
        }

        // ========= è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰å‡¦ç† =========
        async function handleMultiImages(files) {
            currentImage = null;
            previewContainer.style.display = "none";
            markerLayer.innerHTML = "";
            paletteArea.innerHTML = "";
            multiCommentBlock.style.display = "none";

            clearCanvas(toneMapCtx, toneMapCanvas);
            clearCanvas(hueCurveCtx, hueCurveCanvas);
            clearCanvas(toneCurveCtx, toneCurveCanvas);
            clearCanvas(colorBarCtx, colorBarCanvas);

            drawColorMapUnavailable();

            // ========= é›†è¨ˆé…åˆ—ï¼ˆã“ã“ãŒè¶…é‡è¦ï¼ï¼‰=========
            const hueBins = 144;
            const brightBins = 144;

            const hueHist = new Array(hueBins).fill(0);       // â† å¿…é ˆ
            const brightHist = new Array(brightBins).fill(0); // â† å¿…é ˆ

            const barBins = 24;
            const colorBar = new Array(barBins).fill(0);


            for (const file of files) {
                await new Promise(resolve => {
                    const url = URL.createObjectURL(file);
                    const img = new Image();

                    img.onload = () => {
                        const baseW = 260;
                        const scale = baseW / img.width;
                        canvas.width = baseW;
                        canvas.height = img.height * scale;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                        // --- 1ç”»åƒã®å¹³å‡è‰²ç›¸ç”¨ ---
                        let hueSum = 0;
                        let pixelCount = 0;

                        // ===================================================
                        // ã“ã“ï¼ï¼ã“ã® data ã®ãƒ«ãƒ¼ãƒ—å†…ã« å…¥ã‚Œã‚‹ï¼ï¼
                        // ===================================================
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];

                            const { h, v } = rgbToHVS(r, g, b);

                            // ------- HueCurve ç”¨ 144bins -------
                            const hIdx = Math.floor((h / 360) * (hueBins - 1));
                            hueHist[hIdx]++;

                            // ------- ToneCurve ç”¨ 144bins -------
                            const bIdx = Math.floor(v / 255 * (brightBins - 1));
                            brightHist[bIdx]++;

                            // ------- ç”»åƒå¹³å‡è‰²ç›¸ç”¨ -------
                            hueSum += h;
                            pixelCount++;
                        }
                        // ===================================================

                        // 1æšã®å¹³å‡è‰²ç›¸ â†’ ColorBars ç”¨
                        const avgHue = hueSum / pixelCount;
                        const idx = Math.floor((avgHue / 360) * barBins);
                        colorBar[Math.min(barBins - 1, Math.max(0, idx))]++;

                        URL.revokeObjectURL(url);
                        resolve();
                    };

                    img.src = url;
                });
            }


            if (!totalPixels) return;

            // å¹³å‡Hue / Tone ã®æç”»ï¼ˆ144 bins ã®æ»‘ã‚‰ã‹ãªä¸€æœ¬ç·šï¼‰
            drawHueCurveFromHist(hueHist);
            drawToneCurveFromHist(brightHist);
            drawColorBarsFromHist(colorBar);

            // çµ±è¨ˆ â†’ ã‚³ãƒ¡ãƒ³ãƒˆ
            const stats = buildStatsFromHist({
                totalPixels,
                coolCount,
                warmCount,
                shadowsCount,
                midsCount,
                highlightsCount,
                sumSat,
                sumBright,
                sumBrightSq
            });

            const comment = generateAnalysisComment(stats);
            analysisText.textContent = comment;
            multiCommentBlock.style.display = "block";
        }

        // ========= å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =========
        function clearCanvas(context, canvasEl) {
            const w = canvasEl.width = canvasEl.clientWidth || 10;
            const h = canvasEl.height = canvasEl.clientHeight || 10;
            context.clearRect(0, 0, w, h);
        }

        // ========= ãƒ‘ãƒ¬ãƒƒãƒˆæŠ½å‡ºï¼ˆå˜å†™çœŸï¼‰ =========
        function extractPalette(img) {
            canvas.width = 300;
            canvas.height = (img.height / img.width) * 300;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const samples = [];

            for (let i = 0; i < data.length; i += 4 * 10) {
                samples.push([data[i], data[i + 1], data[i + 2]]);
            }

            const palette = kMeans(samples, 5);
            const sorted = palette.sort((a, b) =>
                ((a[0] + a[1] + a[2]) / 3) - ((b[0] + b[1] + b[2]) / 3)
            );

            renderPalette(sorted);
            renderMarkers(sorted);
        }

        // ========== Color Ã— Brightness Mapï¼ˆå˜å†™çœŸå‘ã‘ï¼‰ ==========
        function drawColorBrightnessMap(img) {
            const w = toneMapCanvas.width = toneMapCanvas.clientWidth || 10;
            const h = toneMapCanvas.height = 180;

            canvas.width = 300;
            canvas.height = (img.height / img.width) * 300;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const hueBins = 72;
            const brightBins = 64;
            const hist = Array.from({ length: brightBins },
                () => Array(hueBins).fill(0)
            );

            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i];
                const g = imgData[i + 1];
                const b = imgData[i + 2];

                const { h: hh, v } = rgbToHVS(r, g, b);
                const hueIndex = Math.floor((hh / 360) * (hueBins - 1));
                const brightIndex = Math.floor(v / 255 * (brightBins - 1));

                hist[brightIndex][hueIndex]++;
            }

            let maxCount = 0;
            for (let y = 0; y < brightBins; y++) {
                for (let x = 0; x < hueBins; x++) {
                    if (hist[y][x] > maxCount) maxCount = hist[y][x];
                }
            }

            toneMapCtx.clearRect(0, 0, w, h);

            // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå·¦é’â†’å³ã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
            const bgGrad = toneMapCtx.createLinearGradient(0, 0, w, 0);
            bgGrad.addColorStop(0, "rgba(80,120,190,0.25)");
            bgGrad.addColorStop(0.5, "rgba(255,255,255,0.25)");
            bgGrad.addColorStop(1, "rgba(220,150,90,0.25)");
            toneMapCtx.fillStyle = bgGrad;
            toneMapCtx.fillRect(0, 0, w, h);

            const cellW = w / hueBins;
            const cellH = h / brightBins;

            for (let by = 0; by < brightBins; by++) {
                for (let bx = 0; bx < hueBins; bx++) {
                    const count = hist[by][bx];
                    if (count === 0) continue;

                    const alpha = Math.min(1, count / maxCount);
                    const hue = bx / (hueBins - 1) * 360;

                    toneMapCtx.fillStyle = `hsla(${hue}, 60%, 50%, ${alpha})`;

                    const x = bx * cellW;
                    const y = h - (by + 1) * cellH;
                    toneMapCtx.fillRect(x, y, cellW, cellH);
                }
            }
        }

        // è¤‡æ•°ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼šColorMapéå¯¾å¿œã®æ¡ˆå†…
        function drawColorMapUnavailable() {
            const w = toneMapCanvas.width = toneMapCanvas.clientWidth || 10;
            const h = toneMapCanvas.height = 180;
            toneMapCtx.clearRect(0, 0, w, h);

            toneMapCtx.fillStyle = "rgba(245,242,236,0.95)";
            toneMapCtx.fillRect(0, 0, w, h);

            toneMapCtx.font = "12px 'Inter', system-ui";
            toneMapCtx.fillStyle = "rgba(90,82,74,0.9)";
            toneMapCtx.textAlign = "center";
            toneMapCtx.textBaseline = "middle";
            toneMapCtx.fillText("è¤‡æ•°å†™çœŸãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€Color Ã— Brightness Map ã¯å˜å†™çœŸç”¨ã¨ãªã‚Šã¾ã™ã€‚", w / 2, h / 2);
        }

        // ========== Hue Curveï¼ˆå˜å†™çœŸ from Imageï¼‰ ==========
        // ========== Hue Curveï¼ˆå˜å†™çœŸ from Imageï¼‰ ==========
        // ç”»åƒ1æšã‹ã‚‰ hueHist ã‚’ä½œã£ã¦ã€ãã®ã¾ã¾ drawHueCurveFromHist ã«æ¸¡ã™ç‰ˆ
        function drawHueCurveFromImage(img) {
            // è§£æç”¨ã«å°ã•ã‚ã«ãƒªã‚µã‚¤ã‚º
            canvas.width = 260;
            canvas.height = (img.height / img.width) * 260;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const bins = 144;                     // é™ã‹ãªä¸€æœ¬ç·šç”¨
            const hueHist = new Array(bins).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                const { h } = rgbToHVS(r, g, b);
                const idx = Math.floor((h / 360) * (bins - 1));
                hueHist[idx]++;
            }

            // ãªã‚ã‚‰ã‹æç”»ã¯å…±é€šé–¢æ•°ã«ä»»ã›ã‚‹
            drawHueCurveFromHist(hueHist);
        }

        // ==============================
        // HueCurve èƒŒæ™¯ï¼ˆå…±é€šï¼‰
        // ==============================
        function drawHueBackground(ctx, width, height) {
            const grad = ctx.createLinearGradient(0, 0, width, 0);

            const steps = 24;
            for (let i = 0; i <= steps; i++) {
                const hue = (i / steps) * 360;
                const col = `hsl(${hue}, 60%, 78%)`;
                grad.addColorStop(i / steps, col);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // ğŸ”¥ å·¦ã®é’æš—ãŒã‚Šã‚’è§£æ¶ˆã™ã‚‹ã€Œç™½ã®å‡ä¸€ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.fillRect(0, 0, width, height);
        }



        // ========== Hue Curveï¼ˆãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‹ã‚‰ä¸€æœ¬ç·šã§æç”»ï¼‰ ==========
        function drawHueCurveFromHist(hueHist) {
            const ctx = hueCurveCtx;
            const w = hueCurveCanvas.width = hueCurveCanvas.clientWidth;
            const h = hueCurveCanvas.height = 180;

            ctx.clearRect(0, 0, w, h);

            // èƒŒæ™¯
            drawHueBackground(ctx, w, h);

            // ----- å¹³æ»‘åŒ–ï¼ˆ5ç‚¹å¹³å‡ï¼‰ -----
            const smooth = new Array(hueHist.length).fill(0);

            for (let i = 0; i < hueHist.length; i++) {
                const a = hueHist[(i - 2 + hueHist.length) % hueHist.length];
                const b = hueHist[(i - 1 + hueHist.length) % hueHist.length];
                const c = hueHist[i];
                const d = hueHist[(i + 1) % hueHist.length];
                const e = hueHist[(i + 2) % hueHist.length];
                smooth[i] = (a + b + c + d + e) / 5;
            }

            // æ­£è¦åŒ–
            const maxVal = Math.max(...smooth) || 1;
            const norm = smooth.map(v => v / maxVal);

            // ----- ãƒ©ã‚¤ãƒ³æç”» -----
            ctx.beginPath();
            ctx.lineWidth = 1.6;
            ctx.strokeStyle = "rgba(20,20,20,0.9)";

            const heightScale = h * 0.65;

            for (let i = 0; i < norm.length; i++) {
                const x = i / (norm.length - 1) * w;
                const y = h - norm[i] * heightScale;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        // ======== è¶…ãªã‚ã‚‰ã‹ã‚¬ã‚¦ã‚·ã‚¢ãƒ³å¹³æ»‘ï¼ˆ3ãƒ‘ã‚¹ï¼‰ ========
        function smoothArrayGaussian(arr, passes = 4) {
            let result = [...arr];
            const n = arr.length;

            for (let p = 0; p < passes; p++) {
                const tmp = [...result];
                for (let i = 1; i < n - 1; i++) {
                    tmp[i] = (result[i - 1] + result[i] * 2 + result[i + 1]) / 4;
                }
                result = tmp;
            }
            return result;
        }

        // ========== Tone Curveï¼ˆå˜å†™çœŸ from Imageï¼‰ ==========
        function drawToneCurveFromImage(img) {
            canvas.width = 300;
            canvas.height = (img.height / img.width) * 300;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const bins = 144; // ã“ã¡ã‚‰ã‚‚ 144 bins
            const brightnessHist = new Array(bins).fill(0);

            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i];
                const g = imgData[i + 1];
                const b = imgData[i + 2];

                const { v } = rgbToHVS(r, g, b);
                const brightness = v;
                const index = Math.floor(brightness / 255 * (bins - 1));

                brightnessHist[index]++;
            }

            drawToneCurveFromHist(brightnessHist);
        }

        // ========== Tone Curveï¼ˆãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‹ã‚‰ä¸€æœ¬ç·šã§æç”»ãƒ»è¶…ãªã‚ã‚‰ã‹ç‰ˆï¼‰ ==========
        function drawToneCurveFromHist(brightHist) {
            const w = toneCurveCanvas.width = toneCurveCanvas.clientWidth || 10;
            const h = toneCurveCanvas.height = 180;

            const bins = brightHist.length;
            const maxV = Math.max(...brightHist) || 1;
            const norm = brightHist.map(v => v / maxV);

            const smooth = smoothArrayGaussian(norm, 5);

            toneCurveCtx.clearRect(0, 0, w, h);

            const grad = toneCurveCtx.createLinearGradient(0, 0, w, 0);
            grad.addColorStop(0, "rgba(0,0,0,0.15)");
            grad.addColorStop(1, "rgba(255,255,255,0.15)");
            toneCurveCtx.fillStyle = grad;
            toneCurveCtx.fillRect(0, 0, w, h);

            toneCurveCtx.beginPath();
            toneCurveCtx.lineWidth = 1.6;
            toneCurveCtx.strokeStyle = "rgba(20,20,20,0.9)";

            const heightScale = h * 0.75;

            smooth.forEach((v, i) => {
                const x = (i / (bins - 1)) * w;
                const y = h - v * heightScale;

                if (i === 0) toneCurveCtx.moveTo(x, y);
                else toneCurveCtx.lineTo(x, y);
            });

            toneCurveCtx.stroke();
        }


        // ========== è‰²åˆ†å¸ƒãƒãƒ¼ï¼ˆå˜å†™çœŸç”¨ï¼‰ ==========
        function drawColorBarsSingle(img) {
            const w = colorBarCanvas.width = colorBarCanvas.clientWidth || 10;
            const h = colorBarCanvas.height = 180;

            canvas.width = 260;
            canvas.height = (img.height / img.width) * 260;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const bins = 24;
            const hist = new Array(bins).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const { h: hh } = rgbToHVS(r, g, b);
                const idx = Math.floor((hh / 360) * bins);
                hist[Math.min(bins - 1, Math.max(0, idx))]++;
            }

            drawColorBarsFromHist(hist);
        }

        // ========== è‰²åˆ†å¸ƒãƒãƒ¼ï¼ˆãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‹ã‚‰æç”»ï¼‰ ==========
        function drawColorBarsFromHist(hist) {
            const w = colorBarCanvas.width = colorBarCanvas.clientWidth || 10;
            const h = colorBarCanvas.height = 180;

            colorBarCtx.clearRect(0, 0, w, h);

            const bins = hist.length;
            const maxCount = Math.max(...hist) || 1;

            const barWidth = w / bins;

            for (let i = 0; i < bins; i++) {
                const ratio = hist[i] / maxCount;
                const barH = ratio * (h - 16);

                const x = i * barWidth;
                const y = h - barH;

                // ğŸ”¥ æ£’ã®ä¸­å¤®ã®ã€Œè‰²ç›¸24åŒºé–“ã€ã®è‰²
                const hueCenter = (i + 0.5) / bins * 360;

                // ğŸ”¥ ãã£ãã‚Šã—ãŸãƒãƒ¼ï¼ˆâ€œå¸¯â€ã«ãªã‚‰ãªã„ï¼‰
                colorBarCtx.fillStyle = `hsl(${hueCenter}, 65%, 55%)`;

                // â˜… æ£’ã®å½¢ï¼ˆç«¯ã¯1pxãƒãƒ¼ã‚¸ãƒ³ï¼‰
                colorBarCtx.fillRect(
                    x + 1,     // â† ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—é˜²æ­¢
                    y,
                    barWidth - 2,  // â† éš£ã¨é‡ãªã‚‰ãªã„
                    barH
                );
            }
        }



        // ========== RGB â†’ Hue / Value / Saturation ==========
        function rgbToHVS(r, g, b) {
            const rf = r / 255, gf = g / 255, bf = b / 255;
            const max = Math.max(rf, gf, bf);
            const min = Math.min(rf, gf, bf);
            const v = max * 255;

            let h;
            if (max === min) h = 0;
            else if (max === rf) h = (60 * ((gf - bf) / (max - min)) + 360) % 360;
            else if (max === gf) h = 60 * ((bf - rf) / (max - min)) + 120;
            else h = 60 * ((rf - gf) / (max - min)) + 240;

            const s = max === 0 ? 0 : (max - min) / max;
            return { h, v, s };
        }

        // ========== K-meansï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆç”¨ï¼‰ ==========
        function kMeans(data, k) {
            const centroids = data.slice(0, k);

            for (let iter = 0; iter < 12; iter++) {
                const clusters = Array.from({ length: k }, () => []);

                data.forEach(p => {
                    let best = 0, bestDist = Infinity;
                    centroids.forEach((c, i) => {
                        const d = distance(p, c);
                        if (d < bestDist) { bestDist = d; best = i; }
                    });
                    clusters[best].push(p);
                });

                clusters.forEach((cluster, i) => {
                    if (cluster.length === 0) return;
                    const mean = [0, 0, 0];
                    cluster.forEach(p => {
                        mean[0] += p[0];
                        mean[1] += p[1];
                        mean[2] += p[2];
                    });
                    centroids[i] = mean.map(v => Math.round(v / cluster.length));
                });
            }
            return centroids;
        }

        function distance(a, b) {
            return Math.sqrt(
                (a[0] - b[0]) ** 2 +
                (a[1] - b[1]) ** 2 +
                (a[2] - b[2]) ** 2
            );
        }

        function rgbHex([r, g, b]) {
            const toHex = n => n.toString(16).padStart(2, "0");
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // ========== æŠ½å‡ºè‰²ãƒãƒ¼ã‚«ãƒ¼ï¼ˆå˜å†™çœŸï¼‰ ==========
        function renderMarkers(colors) {
            markerLayer.innerHTML = "";

            const width = canvas.width;
            const height = canvas.height;
            const imgData = ctx.getImageData(0, 0, width, height).data;

            colors.forEach(c => {
                let bestDist = Infinity;
                let bestX = 0, bestY = 0;

                for (let y = 0; y < height; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = (y * width + x) * 4;
                        const r = imgData[idx];
                        const g = imgData[idx + 1];
                        const b = imgData[idx + 2];
                        const d = distance([r, g, b], c);

                        if (d < bestDist) {
                            bestDist = d;
                            bestX = x;
                            bestY = y;
                        }
                    }
                }

                const marker = document.createElement("div");
                marker.className = "color-marker";
                marker.style.background = rgbHex(c);

                const scaleX = previewImg.clientWidth / width;
                const scaleY = previewImg.clientHeight / height;

                marker.style.left = `${bestX * scaleX}px`;
                marker.style.top = `${bestY * scaleY}px`;

                markerLayer.appendChild(marker);
            });
        }

        // ========== ãƒ‘ãƒ¬ãƒƒãƒˆæç”» ==========
        function renderPalette(colors) {
            let html = `<div class="palette-wrap"><div class="color-row">`;

            colors.forEach(c => {
                const hex = rgbHex(c);
                html += `
                    <div class="color-box" style="background:${hex}" onclick="copyCode('${hex}')">
                        <div class="color-code">${hex}</div>
                    </div>`;
            });

            html += `</div></div>`;
            paletteArea.innerHTML = html;
        }

        function copyCode(hex) {
            navigator.clipboard.writeText(hex);
            alert(`ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼š${hex}`);
        }

        // ========== çµ±è¨ˆâ†’ã‚³ãƒ¡ãƒ³ãƒˆç”¨ Stats æ§‹ç¯‰ï¼ˆè¤‡æ•°ãƒ¢ãƒ¼ãƒ‰ï¼‰ ==========
        function buildStatsFromHist(info) {
            const {
                totalPixels,
                coolCount,
                warmCount,
                shadowsCount,
                midsCount,
                highlightsCount,
                sumSat,
                sumBright,
                sumBrightSq
            } = info;

            const stats = {};

            stats.coolRatio = coolCount / totalPixels;
            stats.warmRatio = warmCount / totalPixels;

            stats.shadowsRatio = shadowsCount / totalPixels;
            stats.midsRatio = midsCount / totalPixels;
            stats.highlightsRatio = highlightsCount / totalPixels;

            stats.avgSaturation = sumSat / totalPixels;           // 0ã€œ1
            const meanB = sumBright / totalPixels;
            const meanBSq = sumBrightSq / totalPixels;
            const variance = Math.max(0, meanBSq - meanB * meanB);
            stats.contrastScore = Math.min(1, Math.sqrt(variance) / 128); // ã–ã£ãã‚Š

            return stats;
        }

        // ========== ã‚³ãƒ¡ãƒ³ãƒˆãƒ—ãƒ¼ãƒ«ï¼ˆå®¢è¦³åˆ†æç”¨ï¼‰ ==========
        const commentPools = {
            hueCool: [
                "è‰²ç›¸åˆ†å¸ƒã§ã¯ã€é’ã€œã‚·ã‚¢ãƒ³ç³»ãŒå„ªå‹¢ã§ã€å…¨ä½“ã¨ã—ã¦ã‚¯ãƒ¼ãƒ«ãƒˆãƒ¼ãƒ³å¯„ã‚Šã®å‚¾å‘ãŒè¦‹ã‚‰ã‚Œã¾ã™ã€‚",
                "é’ç³»ã®æ¯”ç‡ãŒé«˜ãã€è‰²ç›¸ã¯å†·ãŸã„å´ã«å¯„ã£ãŸæ§‹æˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "å¯’è‰²æˆåˆ†ãŒå¤šãã€ç”»é¢å…¨ä½“ãŒã‚„ã‚„ä½ã„è‰²æ¸©åº¦ã§çµ±ä¸€ã•ã‚Œã¦ã„ã¾ã™ã€‚"
            ],
            hueWarm: [
                "è‰²ç›¸åˆ†å¸ƒã§ã¯ã€é»„ã€œæ©™ã€œèµ¤ç³»ã®æ¯”ç‡ãŒé«˜ãã€ã‚¦ã‚©ãƒ¼ãƒ ãƒˆãƒ¼ãƒ³å¯„ã‚Šã®å‚¾å‘ãŒè¦‹ã‚‰ã‚Œã¾ã™ã€‚",
                "æš–è‰²æˆåˆ†ãŒå„ªå‹¢ã§ã€å…¨ä½“ã¨ã—ã¦é«˜ã‚ã®è‰²æ¸©åº¦ã‚’æ„Ÿã˜ã‚‹æ§‹æˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "æ©™ã€œèµ¤ç³»ã®å¯„ä¸ãŒå¤§ããã€æ¸©ã‹ã¿ã®ã‚ã‚‹è‰²ç›¸ãƒãƒ©ãƒ³ã‚¹ãŒç‰¹å¾´çš„ã§ã™ã€‚"
            ],
            hueNeutral: [
                "å¯’è‰²ã¨æš–è‰²ã®æ¯”ç‡ãŒå¤§ããã¯åã‚‰ãšã€ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«ã«è¿‘ã„è‰²ç›¸ãƒãƒ©ãƒ³ã‚¹ã§ã™ã€‚",
                "é’ç³»ãƒ»æš–è‰²ç³»ã¨ã‚‚ã«ä¸€å®šé‡å«ã¾ã‚Œã€è‰²ç›¸ã®åã‚Šã¯æ¯”è¼ƒçš„å°‘ãªã„æ§‹æˆã§ã™ã€‚",
                "ç‰¹å®šã®è‰²ç›¸ã«å¤§ããå¯„ã‚‰ãšã€ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸè‰²ç›¸åˆ†å¸ƒã«ãªã£ã¦ã„ã¾ã™."
            ],
            toneLowKey: [
                "æ˜åº¦åˆ†å¸ƒã§ã¯ã‚·ãƒ£ãƒ‰ã‚¦åŸŸã®æ¯”ç‡ãŒé«˜ãã€ãƒ­ãƒ¼ã‚­ãƒ¼å¯„ã‚Šã®ãƒˆãƒ¼ãƒ³è¨­è¨ˆã¨ãªã£ã¦ã„ã¾ã™ã€‚",
                "æš—éƒ¨ã®å æœ‰ç‡ãŒå¤§ããã€ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯æ§ãˆã‚ãªæ§‹æˆã§ã™ã€‚",
                "ã‚·ãƒ£ãƒ‰ã‚¦æˆåˆ†ãŒå„ªå‹¢ã§ã€å…¨ä½“ã¨ã—ã¦ä½ã‚ã®æ˜åº¦ãƒ¬ãƒ³ã‚¸ã§ã¾ã¨ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"
            ],
            toneMid: [
                "ä¸­é–“èª¿ã®æ¯”ç‡ãŒæœ€ã‚‚é«˜ãã€æ¥µç«¯ãªæš—éƒ¨ã‚„ãƒã‚¤ãƒ©ã‚¤ãƒˆã«ä¾å­˜ã—ãªã„å®‰å®šã—ãŸãƒˆãƒ¼ãƒ³æ§‹æˆã§ã™ã€‚",
                "æ˜åº¦ã®ä¸­å¿ƒã¯ãƒŸãƒƒãƒ‰ãƒˆãƒ¼ãƒ³ä»˜è¿‘ã«ã‚ã‚Šã€ãƒãƒ©ãƒ³ã‚¹å‹ã®ãƒˆãƒ¼ãƒ³åˆ†å¸ƒã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "ã‚·ãƒ£ãƒ‰ã‚¦ãƒ»ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚ˆã‚Šã‚‚ä¸­é–“èª¿ãŒå„ªå‹¢ã§ã€ç©ã‚„ã‹ãªæ˜åº¦ãƒãƒ©ãƒ³ã‚¹ã§ã™ã€‚"
            ],
            toneHighKey: [
                "ãƒã‚¤ãƒ©ã‚¤ãƒˆåŸŸã®æ¯”ç‡ãŒé«˜ãã€å…¨ä½“ã¨ã—ã¦ãƒã‚¤ã‚­ãƒ¼å¯„ã‚Šã®ãƒˆãƒ¼ãƒ³è¨­è¨ˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "æ˜éƒ¨ã®å æœ‰ç‡ãŒå¤§ããã€æš—éƒ¨ã¯å°‘ãªã‚ã®æ§‹æˆã§ã™ã€‚",
                "é«˜æ˜åº¦æˆåˆ†ãŒå„ªå‹¢ã§ã€æ˜ã‚‹ã„ãƒ¬ãƒ³ã‚¸ã«å¯„ã£ãŸãƒˆãƒ¼ãƒ³åˆ†å¸ƒãŒç‰¹å¾´çš„ã§ã™ã€‚"
            ],
            satLow: [
                "å½©åº¦ã¯å…¨ä½“ã¨ã—ã¦æ§ãˆã‚ã§ã€ä½ã€œä¸­å½©åº¦ã‚’ä¸­å¿ƒã¨ã—ãŸè½ã¡ç€ã„ãŸè‰²è¨­è¨ˆã«ãªã£ã¦ã„ã¾ã™.",
                "é«˜å½©åº¦æˆåˆ†ã¯å°‘ãªãã€æŠ‘åˆ¶ã•ã‚ŒãŸè‰²ä½¿ã„ãŒä¸€è²«ã—ã¦ã„ã¾ã™ã€‚",
                "é£½å’Œåº¦ã¯ä½ã‚ã§ã€æ´¾æ‰‹ã•ã‚ˆã‚Šã‚‚ãƒˆãƒ¼ãƒ³ã¨æ˜åº¦ã®å·®ã§ç”»é¢ãŒæ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚"
            ],
            satMid: [
                "å½©åº¦ã¯ä¸­ç¨‹åº¦ã§ã€å¿…è¦ãªç¯„å›²ã ã‘ãŒå¼·èª¿ã•ã‚Œã‚‹ãƒãƒ©ãƒ³ã‚¹å‹ã®è‰²è¨­è¨ˆã§ã™ã€‚",
                "æ¥µç«¯ã«ä½å½©åº¦ã§ã‚‚é«˜å½©åº¦ã§ã‚‚ãªãã€ä¸­åº¸ãªé£½å’Œåº¦ãŒä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚",
                "å…¨ä½“ã¨ã—ã¦ä¸­å½©åº¦åŸŸãŒä¸­å¿ƒã§ã€è‰²ã®ä¸»å¼µã¨è½ã¡ç€ããŒå…±å­˜ã™ã‚‹æ§‹æˆã§ã™ã€‚"
            ],
            satHigh: [
                "é«˜å½©åº¦æˆåˆ†ãŒå¤šãã€è‰²ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆãŒå¼·ã‚ã«åŠ¹ã„ãŸæ§‹æˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "é£½å’Œåº¦ã¯é«˜ãã€è¦–ç·šã‚’å¼•ãã¤ã‘ã‚‹è‰²ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆãŒå¤šãå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚",
                "ãƒ“ãƒ“ãƒƒãƒ‰ãªè‰²ãŒç”»é¢ã®ä¸­ã§ä¸€å®šã®å‰²åˆã‚’å ã‚ã‚‹ã€é®®ã‚„ã‹ã•ã®ã‚ã‚‹å‚¾å‘ã§ã™ã€‚"
            ],
            contrastLow: [
                "æ˜åº¦åˆ†å¸ƒã®ã°ã‚‰ã¤ãã¯å°ã•ãã€ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã¯å¼±ã‚ã®å‚¾å‘ã§ã™ã€‚",
                "æš—éƒ¨ã‹ã‚‰ãƒã‚¤ãƒ©ã‚¤ãƒˆã¾ã§ã®å·®ã¯æ¯”è¼ƒçš„ç·©ã‚„ã‹ã§ã€ãƒ•ãƒ©ãƒƒãƒˆå¯„ã‚Šã®ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "å¼·ã„æ˜æš—å·®ã¯å°‘ãªãã€æ»‘ã‚‰ã‹ãªéšèª¿å¤‰åŒ–ãŒä¸­å¿ƒã®ãƒˆãƒ¼ãƒ³è¨­è¨ˆã§ã™ã€‚"
            ],
            contrastMid: [
                "ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã¯ä¸­ç¨‹åº¦ã§ã€æš—éƒ¨ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆã®å·®ãŒéåº¦ã«å¼·èª¿ã•ã‚Œãªã„ãƒãƒ©ãƒ³ã‚¹ã®è‰¯ã„æ§‹æˆã§ã™ã€‚",
                "æ˜æš—å·®ã¯é©åº¦ã§ã€æƒ…å ±é‡ã¨è¦‹ã‚„ã™ã•ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚ŒãŸãƒ¬ãƒ³ã‚¸æ„Ÿã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã¯æ¨™æº–åŸŸã§ã€éšèª¿å†ç¾ã¨è¦–èªæ€§ã®ä¸¡ç«‹ãŒå›³ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚"
            ],
            contrastHigh: [
                "æ˜åº¦ã®ã°ã‚‰ã¤ããŒå¤§ããã€ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã¯å¼·ã‚ã®å‚¾å‘ã§ã™ã€‚",
                "ã‚·ãƒ£ãƒ‰ã‚¦ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆã®å·®ãŒå¤§ããã€ãƒ¡ãƒªãƒãƒªã®ã‚ã‚‹ãƒˆãƒ¼ãƒ³æ§‹æˆã«ãªã£ã¦ã„ã¾ã™ã€‚",
                "é«˜ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆå¯„ã‚Šã§ã€æ˜æš—ã®å¢ƒç•ŒãŒã¯ã£ãã‚Šã¨ã—ãŸéšèª¿è¨­è¨ˆã§ã™ã€‚"
            ],
            summary: [
                "ç·åˆçš„ã«ã¯ã€è‰²ç›¸ãƒ»æ˜åº¦ãƒ»å½©åº¦ã¨ã‚‚ã«ä¸€å®šã®ä¸€è²«æ€§ãŒã‚ã‚Šã€ä½œé¢¨ã¨ã—ã¦ã®æ–¹å‘æ€§ãŒã¯ã£ãã‚Šã¨è¡¨ã‚Œã¦ã„ã¾ã™ã€‚",
                "å…¨ä½“ã®çµ±è¨ˆã‹ã‚‰ã€è‰²ã‚„ãƒˆãƒ¼ãƒ³ã®é¸æŠã«æ˜ç¢ºãªå‚¾å‘ãŒè¦‹ã‚‰ã‚Œã€ä½œå®¶ã¨ã—ã¦ã®å¥½ã¿ãŒãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ã‚‚ç¢ºèªã§ãã¾ã™ã€‚",
                "ã“ã‚Œã‚‰ã®å‚¾å‘ã¯ã€ä½œå“ç¾¤ã‚’é€šã—ã¦å…±é€šã™ã‚‹â€œè‰²ã¨å…‰ã®è¨­è¨ˆâ€ã¨ã—ã¦ä¸€è²«ã—ã¦ç¾ã‚Œã¦ã„ã¾ã™ã€‚"
            ]
        };

        // ========== Stats â†’ ã‚¿ã‚°åˆ†é¡ ==========
        function classifyStats(stats) {
            const tags = [];

            // Hue
            if (stats.coolRatio > stats.warmRatio + 0.08) {
                tags.push("hueCool");
            } else if (stats.warmRatio > stats.coolRatio + 0.08) {
                tags.push("hueWarm");
            } else {
                tags.push("hueNeutral");
            }

            // Tone
            if (stats.shadowsRatio > 0.45 && stats.highlightsRatio < 0.2) {
                tags.push("toneLowKey");
            } else if (stats.highlightsRatio > 0.35) {
                tags.push("toneHighKey");
            } else {
                tags.push("toneMid");
            }

            // Saturation
            if (stats.avgSaturation < 0.28) {
                tags.push("satLow");
            } else if (stats.avgSaturation > 0.55) {
                tags.push("satHigh");
            } else {
                tags.push("satMid");
            }

            // Contrast
            if (stats.contrastScore < 0.35) {
                tags.push("contrastLow");
            } else if (stats.contrastScore > 0.60) {
                tags.push("contrastHigh");
            } else {
                tags.push("contrastMid");
            }

            return tags;
        }

        function pickRandom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // ========== åˆ†æã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆï¼ˆè¤‡æ•°ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ï¼‰ ==========
        function generateAnalysisComment(stats) {
            const tags = classifyStats(stats);
            const sentences = [];

            tags.forEach(tag => {
                const pool = commentPools[tag];
                if (pool && pool.length) {
                    sentences.push(pickRandom(pool));
                }
            });

            // ã¾ã¨ã‚æ–‡
            sentences.push(pickRandom(commentPools.summary));

            // 3è¡Œå‰å¾Œã«æŠ‘ãˆã‚‹ï¼ˆ2ã€œ4æ–‡ãã‚‰ã„ï¼‰
            const maxSentences = 3;
            const trimmed = sentences.slice(0, maxSentences);

            return trimmed.join("\n");
        }
    </script>
</body>

</html>